(* Generated by coq-of-solidity *)
Require Import CoqOfSolidity.CoqOfSolidity.

(* License: WTFPL *)

(* Pragma solidity>=0.8.0 *)

Require test.libsolidity.semanticTests.externalContracts._prbmath.PRBMathCommon.


(* Library *)
Module PRBMathSD59x18.
  Definition LOG2_E : Value.t :=
    Value.Integer 1442695040888963407.

  Definition HALF_SCALE : Value.t :=
    Value.Integer 5e17.

  Definition MAX_SD59x18 : Value.t :=
    Value.Integer 57896044618658097711785492504343953926634992332820282019728792003956564819967.

  Definition MAX_WHOLE_SD59x18 : Value.t :=
    Value.Integer 57896044618658097711785492504343953926634992332820282019728000000000000000000.

  Definition MIN_SD59x18 : Value.t :=
    M.un_op (|
      true,
      "-",
      Value.Integer 57896044618658097711785492504343953926634992332820282019728792003956564819968
    |).

  Definition MIN_WHOLE_SD59x18 : Value.t :=
    M.un_op (|
      true,
      "-",
      Value.Integer 57896044618658097711785492504343953926634992332820282019728000000000000000000
    |).

  Definition SCALE : Value.t :=
    Value.Integer 1e18.

  Definition abs (α : list Value.t) : M :=
    match α with
    | [x] =>
      let _ :=
        let _ :=
          M.call (|
            M.get_name (| "require" |),
            [
              M.bin_op (|
                ">",
                M.get_name (| "x" |),
                M.get_name (| "MIN_SD59x18" |)
              |)
            ]
          |) in
        let _ :=
          M.assign (|
            "=",
            M.get_name (| "result" |),
            Conditional M.bin_op (|
              "<",
              M.get_name (| "x" |),
              Value.Integer 0
            |) M.un_op (|
              true,
              "-",
              M.get_name (| "x" |)
            |) M.get_name (| "x" |)

          |) in
        Value.Tuple [] in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition avg (α : list Value.t) : M :=
    match α with
    | [x, y] =>
      let _ :=
        let _ :=
          M.assign (|
            "=",
            M.get_name (| "result" |),
            M.bin_op (|
              "+",
              M.bin_op (|
                "+",
                Value.Tuple [
                  M.bin_op (|
                    ">>",
                    M.get_name (| "x" |),
                    Value.Integer 1
                  |)
                ],
                Value.Tuple [
                  M.bin_op (|
                    ">>",
                    M.get_name (| "y" |),
                    Value.Integer 1
                  |)
                ]
              |),
              Value.Tuple [
                M.bin_op (|
                  "&",
                  M.bin_op (|
                    "&",
                    M.get_name (| "x" |),
                    M.get_name (| "y" |)
                  |),
                  Value.Integer 1
                |)
              ]
            |)
          |) in
        Value.Tuple [] in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition ceil (α : list Value.t) : M :=
    match α with
    | [x] =>
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              "<=",
              M.get_name (| "x" |),
              M.get_name (| "MAX_WHOLE_SD59x18" |)
            |)
          ]
        |) in
      let _ :=
        let _ :=
          M.define (|
            [ "remainder" ],
            M.bin_op (|
              "%",
              M.get_name (| "x" |),
              M.get_name (| "SCALE" |)
            |)
          |) in
        let _ :=
          if M.bin_op (|
            "==",
            M.get_name (| "remainder" |),
            Value.Integer 0
          |) then
            let _ :=
              M.assign (|
                "=",
                M.get_name (| "result" |),
                M.get_name (| "x" |)
              |) in
            Value.Tuple []
          else
            let _ :=
              M.assign (|
                "=",
                M.get_name (| "result" |),
                M.bin_op (|
                  "-",
                  M.get_name (| "x" |),
                  M.get_name (| "remainder" |)
                |)
              |) in
            let _ :=
              if M.bin_op (|
                ">",
                M.get_name (| "x" |),
                Value.Integer 0
              |) then
                let _ :=
                  M.assign (|
                    "+=",
                    M.get_name (| "result" |),
                    M.get_name (| "SCALE" |)
                  |) in
                Value.Tuple []
              else
                Value.Tuple [] in
            Value.Tuple [] in
        Value.Tuple [] in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition div (α : list Value.t) : M :=
    match α with
    | [x, y] =>
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              ">",
              M.get_name (| "x" |),
              M.member_access (|
                M.call (|
                  M.get_name (| "type" |),
                  [
                    Ty.path "int256"
                  ]
                |),
                "min"
              |)
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              ">",
              M.get_name (| "y" |),
              M.member_access (|
                M.call (|
                  M.get_name (| "type" |),
                  [
                    Ty.path "int256"
                  ]
                |),
                "min"
              |)
            |)
          ]
        |) in
      let _ :=
        M.define (|
          [ "ax" ],
          Value.Default
        |) in
      let _ :=
        M.define (|
          [ "ay" ],
          Value.Default
        |) in
      let _ :=
        let _ :=
          M.assign (|
            "=",
            M.get_name (| "ax" |),
            Conditional M.bin_op (|
              "<",
              M.get_name (| "x" |),
              Value.Integer 0
            |) M.call (|
              Ty.path "uint256",
              [
                M.un_op (|
                  true,
                  "-",
                  M.get_name (| "x" |)
                |)
              ]
            |) M.call (|
              Ty.path "uint256",
              [
                M.get_name (| "x" |)
              ]
            |)

          |) in
        let _ :=
          M.assign (|
            "=",
            M.get_name (| "ay" |),
            Conditional M.bin_op (|
              "<",
              M.get_name (| "y" |),
              Value.Integer 0
            |) M.call (|
              Ty.path "uint256",
              [
                M.un_op (|
                  true,
                  "-",
                  M.get_name (| "y" |)
                |)
              ]
            |) M.call (|
              Ty.path "uint256",
              [
                M.get_name (| "y" |)
              ]
            |)

          |) in
        Value.Tuple [] in
      let _ :=
        M.define (|
          [ "resultUnsigned" ],
          M.call (|
            M.member_access (|
              M.get_name (| "PRBMathCommon" |),
              "mulDiv"
            |),
            [
              M.get_name (| "ax" |),
              M.call (|
                Ty.path "uint256",
                [
                  M.get_name (| "SCALE" |)
                ]
              |),
              M.get_name (| "ay" |)
            ]
          |)
        |) in
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              "<=",
              M.get_name (| "resultUnsigned" |),
              M.call (|
                Ty.path "uint256",
                [
                  M.member_access (|
                    M.call (|
                      M.get_name (| "type" |),
                      [
                        Ty.path "int256"
                      ]
                    |),
                    "max"
                  |)
                ]
              |)
            |)
          ]
        |) in
      let _ :=
        M.define (|
          [ "sx" ],
          Value.Default
        |) in
      let _ :=
        M.define (|
          [ "sy" ],
          Value.Default
        |) in
      let _ :=
        (* Beginning of a node! *)
id: 237
src: 5596:92:1
nodeType: InlineAssembly
AST: TODO YulJson
externalReferences: src: 5619:2:1declaration: 232isSlot: isOffset: alueSize: src: 5655:2:1declaration: 235isSlot: isOffset: alueSize: src: 5629:1:1declaration: 140isSlot: isOffset: alueSize: src: 5665:1:1declaration: 142isSlot: isOffset: alueSize: 
evmVersion: cancun
 in
      let _ :=
        M.assign (|
          "=",
          M.get_name (| "result" |),
          Conditional M.bin_op (|
            "==",
            M.bin_op (|
              "^",
              M.get_name (| "sx" |),
              M.get_name (| "sy" |)
            |),
            Value.Integer 1
          |) M.un_op (|
            true,
            "-",
            M.call (|
              Ty.path "int256",
              [
                M.get_name (| "resultUnsigned" |)
              ]
            |)
          |) M.call (|
            Ty.path "int256",
            [
              M.get_name (| "resultUnsigned" |)
            ]
          |)

        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition e (α : list Value.t) : M :=
    match α with
    | [] =>
      let _ :=
        M.assign (|
          "=",
          M.get_name (| "result" |),
          Value.Integer 2718281828459045235
        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition exp (α : list Value.t) : M :=
    match α with
    | [x] =>
      let _ :=
        if M.bin_op (|
          "<",
          M.get_name (| "x" |),
          M.un_op (|
            true,
            "-",
            Value.Integer 41446531673892822322
          |)
        |) then
          let _ :=
            M.return_ (|
              Value.Integer 0
            |) in
          Value.Tuple []
        else
          Value.Tuple [] in
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              "<",
              M.get_name (| "x" |),
              Value.Integer 88722839111672999628
            |)
          ]
        |) in
      let _ :=
        let _ :=
          M.define (|
            [ "doubleScaleProduct" ],
            M.bin_op (|
              "*",
              M.get_name (| "x" |),
              M.get_name (| "LOG2_E" |)
            |)
          |) in
        let _ :=
          M.assign (|
            "=",
            M.get_name (| "result" |),
            M.call (|
              M.get_name (| "exp2" |),
              [
                M.bin_op (|
                  "/",
                  Value.Tuple [
                    M.bin_op (|
                      "+",
                      M.get_name (| "doubleScaleProduct" |),
                      M.get_name (| "HALF_SCALE" |)
                    |)
                  ],
                  M.get_name (| "SCALE" |)
                |)
              ]
            |)
          |) in
        Value.Tuple [] in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition exp2 (α : list Value.t) : M :=
    match α with
    | [x] =>
      let _ :=
        if M.bin_op (|
          "<",
          M.get_name (| "x" |),
          Value.Integer 0
        |) then
          let _ :=
            if M.bin_op (|
              "<",
              M.get_name (| "x" |),
              M.un_op (|
                true,
                "-",
                Value.Integer 59794705707972522261
              |)
            |) then
              let _ :=
                M.return_ (|
                  Value.Integer 0
                |) in
              Value.Tuple []
            else
              Value.Tuple [] in
          let _ :=
            let _ :=
              M.assign (|
                "=",
                M.get_name (| "result" |),
                M.bin_op (|
                  "/",
                  Value.Integer 1e36,
                  M.call (|
                    M.get_name (| "exp2" |),
                    [
                      M.un_op (|
                        true,
                        "-",
                        M.get_name (| "x" |)
                      |)
                    ]
                  |)
                |)
              |) in
            Value.Tuple [] in
          Value.Tuple []
        else
          let _ :=
            M.call (|
              M.get_name (| "require" |),
              [
                M.bin_op (|
                  "<",
                  M.get_name (| "x" |),
                  Value.Integer 128e18
                |)
              ]
            |) in
          let _ :=
            let _ :=
              M.define (|
                [ "x128x128" ],
                M.bin_op (|
                  "/",
                  Value.Tuple [
                    M.bin_op (|
                      "<<",
                      M.call (|
                        Ty.path "uint256",
                        [
                          M.get_name (| "x" |)
                        ]
                      |),
                      Value.Integer 128
                    |)
                  ],
                  M.call (|
                    Ty.path "uint256",
                    [
                      M.get_name (| "SCALE" |)
                    ]
                  |)
                |)
              |) in
            let _ :=
              M.assign (|
                "=",
                M.get_name (| "result" |),
                M.call (|
                  Ty.path "int256",
                  [
                    M.call (|
                      M.member_access (|
                        M.get_name (| "PRBMathCommon" |),
                        "exp2"
                      |),
                      [
                        M.get_name (| "x128x128" |)
                      ]
                    |)
                  ]
                |)
              |) in
            Value.Tuple [] in
          Value.Tuple [] in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition floor (α : list Value.t) : M :=
    match α with
    | [x] =>
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              ">=",
              M.get_name (| "x" |),
              M.get_name (| "MIN_WHOLE_SD59x18" |)
            |)
          ]
        |) in
      let _ :=
        let _ :=
          M.define (|
            [ "remainder" ],
            M.bin_op (|
              "%",
              M.get_name (| "x" |),
              M.get_name (| "SCALE" |)
            |)
          |) in
        let _ :=
          if M.bin_op (|
            "==",
            M.get_name (| "remainder" |),
            Value.Integer 0
          |) then
            let _ :=
              M.assign (|
                "=",
                M.get_name (| "result" |),
                M.get_name (| "x" |)
              |) in
            Value.Tuple []
          else
            let _ :=
              M.assign (|
                "=",
                M.get_name (| "result" |),
                M.bin_op (|
                  "-",
                  M.get_name (| "x" |),
                  M.get_name (| "remainder" |)
                |)
              |) in
            let _ :=
              if M.bin_op (|
                "<",
                M.get_name (| "x" |),
                Value.Integer 0
              |) then
                let _ :=
                  M.assign (|
                    "-=",
                    M.get_name (| "result" |),
                    M.get_name (| "SCALE" |)
                  |) in
                Value.Tuple []
              else
                Value.Tuple [] in
            Value.Tuple [] in
        Value.Tuple [] in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition frac (α : list Value.t) : M :=
    match α with
    | [x] =>
      let _ :=
        let _ :=
          M.assign (|
            "=",
            M.get_name (| "result" |),
            M.bin_op (|
              "%",
              M.get_name (| "x" |),
              M.get_name (| "SCALE" |)
            |)
          |) in
        Value.Tuple [] in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition gm (α : list Value.t) : M :=
    match α with
    | [x, y] =>
      let _ :=
        if M.bin_op (|
          "==",
          M.get_name (| "x" |),
          Value.Integer 0
        |) then
          let _ :=
            M.return_ (|
              Value.Integer 0
            |) in
          Value.Tuple []
        else
          Value.Tuple [] in
      let _ :=
        let _ :=
          M.define (|
            [ "xy" ],
            M.bin_op (|
              "*",
              M.get_name (| "x" |),
              M.get_name (| "y" |)
            |)
          |) in
        let _ :=
          M.call (|
            M.get_name (| "require" |),
            [
              M.bin_op (|
                "==",
                M.bin_op (|
                  "/",
                  M.get_name (| "xy" |),
                  M.get_name (| "x" |)
                |),
                M.get_name (| "y" |)
              |)
            ]
          |) in
        let _ :=
          M.call (|
            M.get_name (| "require" |),
            [
              M.bin_op (|
                ">=",
                M.get_name (| "xy" |),
                Value.Integer 0
              |)
            ]
          |) in
        let _ :=
          M.assign (|
            "=",
            M.get_name (| "result" |),
            M.call (|
              Ty.path "int256",
              [
                M.call (|
                  M.member_access (|
                    M.get_name (| "PRBMathCommon" |),
                    "sqrt"
                  |),
                  [
                    M.call (|
                      Ty.path "uint256",
                      [
                        M.get_name (| "xy" |)
                      ]
                    |)
                  ]
                |)
              ]
            |)
          |) in
        Value.Tuple [] in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition inv (α : list Value.t) : M :=
    match α with
    | [x] =>
      let _ :=
        let _ :=
          M.assign (|
            "=",
            M.get_name (| "result" |),
            M.bin_op (|
              "/",
              Value.Integer 1e36,
              M.get_name (| "x" |)
            |)
          |) in
        Value.Tuple [] in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition ln (α : list Value.t) : M :=
    match α with
    | [x] =>
      let _ :=
        let _ :=
          M.assign (|
            "=",
            M.get_name (| "result" |),
            M.bin_op (|
              "/",
              Value.Tuple [
                M.bin_op (|
                  "*",
                  M.call (|
                    M.get_name (| "log2" |),
                    [
                      M.get_name (| "x" |)
                    ]
                  |),
                  M.get_name (| "SCALE" |)
                |)
              ],
              M.get_name (| "LOG2_E" |)
            |)
          |) in
        Value.Tuple [] in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition log10 (α : list Value.t) : M :=
    match α with
    | [x] =>
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              ">",
              M.get_name (| "x" |),
              Value.Integer 0
            |)
          ]
        |) in
      let _ :=
        (* Beginning of a node! *)
id: 540
src: 13696:6859:1
nodeType: InlineAssembly
AST: TODO YulJson
externalReferences: src: 20520:11:1declaration: 15isSlot: isOffset: alueSize: src: 13763:5:1declaration: 33isSlot: isOffset: alueSize: src: 13820:5:1declaration: 33isSlot: isOffset: alueSize: src: 13878:5:1declaration: 33isSlot: isOffset: alueSize: src: 13937:5:1declaration: 33isSlot: isOffset: alueSize: src: 13997:5:1declaration: 33isSlot: isOffset: alueSize: src: 14058:5:1declaration: 33isSlot: isOffset: alueSize: src: 14120:5:1declaration: 33isSlot: isOffset: alueSize: src: 14183:5:1declaration: 33isSlot: isOffset: alueSize: src: 14247:5:1declaration: 33isSlot: isOffset: alueSize: src: 14312:5:1declaration: 33isSlot: isOffset: alueSize: src: 14378:5:1declaration: 33isSlot: isOffset: alueSize: src: 14446:5:1declaration: 33isSlot: isOffset: alueSize: src: 14515:5:1declaration: 33isSlot: isOffset: alueSize: src: 14585:5:1declaration: 33isSlot: isOffset: alueSize: src: 14656:5:1declaration: 33isSlot: isOffset: alueSize: src: 14728:5:1declaration: 33isSlot: isOffset: alueSize: src: 14801:5:1declaration: 33isSlot: isOffset: alueSize: src: 14875:5:1declaration: 33isSlot: isOffset: alueSize: src: 15000:5:1declaration: 33isSlot: isOffset: alueSize: src: 15063:5:1declaration: 33isSlot: isOffset: alueSize: src: 15131:5:1declaration: 33isSlot: isOffset: alueSize: src: 15200:5:1declaration: 33isSlot: isOffset: alueSize: src: 15270:5:1declaration: 33isSlot: isOffset: alueSize: src: 15341:5:1declaration: 33isSlot: isOffset: alueSize: src: 15413:5:1declaration: 33isSlot: isOffset: alueSize: src: 15486:5:1declaration: 33isSlot: isOffset: alueSize: src: 15560:5:1declaration: 33isSlot: isOffset: alueSize: src: 15635:5:1declaration: 33isSlot: isOffset: alueSize: src: 15712:5:1declaration: 33isSlot: isOffset: alueSize: src: 15790:5:1declaration: 33isSlot: isOffset: alueSize: src: 15869:5:1declaration: 33isSlot: isOffset: alueSize: src: 15949:5:1declaration: 33isSlot: isOffset: alueSize: src: 16030:5:1declaration: 33isSlot: isOffset: alueSize: src: 16112:5:1declaration: 33isSlot: isOffset: alueSize: src: 16195:5:1declaration: 33isSlot: isOffset: alueSize: src: 16279:5:1declaration: 33isSlot: isOffset: alueSize: src: 16364:5:1declaration: 33isSlot: isOffset: alueSize: src: 16450:5:1declaration: 33isSlot: isOffset: alueSize: src: 16537:5:1declaration: 33isSlot: isOffset: alueSize: src: 16625:5:1declaration: 33isSlot: isOffset: alueSize: src: 16714:5:1declaration: 33isSlot: isOffset: alueSize: src: 16804:5:1declaration: 33isSlot: isOffset: alueSize: src: 16895:5:1declaration: 33isSlot: isOffset: alueSize: src: 16987:5:1declaration: 33isSlot: isOffset: alueSize: src: 17080:5:1declaration: 33isSlot: isOffset: alueSize: src: 17174:5:1declaration: 33isSlot: isOffset: alueSize: src: 17269:5:1declaration: 33isSlot: isOffset: alueSize: src: 17365:5:1declaration: 33isSlot: isOffset: alueSize: src: 17462:5:1declaration: 33isSlot: isOffset: alueSize: src: 17560:5:1declaration: 33isSlot: isOffset: alueSize: src: 17659:5:1declaration: 33isSlot: isOffset: alueSize: src: 17759:5:1declaration: 33isSlot: isOffset: alueSize: src: 17860:5:1declaration: 33isSlot: isOffset: alueSize: src: 17962:5:1declaration: 33isSlot: isOffset: alueSize: src: 18065:5:1declaration: 33isSlot: isOffset: alueSize: src: 18169:5:1declaration: 33isSlot: isOffset: alueSize: src: 18274:5:1declaration: 33isSlot: isOffset: alueSize: src: 18380:5:1declaration: 33isSlot: isOffset: alueSize: src: 18487:5:1declaration: 33isSlot: isOffset: alueSize: src: 18595:5:1declaration: 33isSlot: isOffset: alueSize: src: 18704:5:1declaration: 33isSlot: isOffset: alueSize: src: 18814:5:1declaration: 33isSlot: isOffset: alueSize: src: 18925:5:1declaration: 33isSlot: isOffset: alueSize: src: 19037:5:1declaration: 33isSlot: isOffset: alueSize: src: 19150:5:1declaration: 33isSlot: isOffset: alueSize: src: 19264:5:1declaration: 33isSlot: isOffset: alueSize: src: 19379:5:1declaration: 33isSlot: isOffset: alueSize: src: 19495:5:1declaration: 33isSlot: isOffset: alueSize: src: 19612:5:1declaration: 33isSlot: isOffset: alueSize: src: 19730:5:1declaration: 33isSlot: isOffset: alueSize: src: 19849:5:1declaration: 33isSlot: isOffset: alueSize: src: 19969:5:1declaration: 33isSlot: isOffset: alueSize: src: 20090:5:1declaration: 33isSlot: isOffset: alueSize: src: 20212:5:1declaration: 33isSlot: isOffset: alueSize: src: 20335:5:1declaration: 33isSlot: isOffset: alueSize: src: 20459:5:1declaration: 33isSlot: isOffset: alueSize: src: 13749:6:1declaration: 532isSlot: isOffset: alueSize: src: 13806:6:1declaration: 532isSlot: isOffset: alueSize: src: 13864:6:1declaration: 532isSlot: isOffset: alueSize: src: 13923:6:1declaration: 532isSlot: isOffset: alueSize: src: 13983:6:1declaration: 532isSlot: isOffset: alueSize: src: 14044:6:1declaration: 532isSlot: isOffset: alueSize: src: 14106:6:1declaration: 532isSlot: isOffset: alueSize: src: 14169:6:1declaration: 532isSlot: isOffset: alueSize: src: 14233:6:1declaration: 532isSlot: isOffset: alueSize: src: 14298:6:1declaration: 532isSlot: isOffset: alueSize: src: 14364:6:1declaration: 532isSlot: isOffset: alueSize: src: 14432:6:1declaration: 532isSlot: isOffset: alueSize: src: 14501:6:1declaration: 532isSlot: isOffset: alueSize: src: 14571:6:1declaration: 532isSlot: isOffset: alueSize: src: 14642:6:1declaration: 532isSlot: isOffset: alueSize: src: 14714:6:1declaration: 532isSlot: isOffset: alueSize: src: 14787:6:1declaration: 532isSlot: isOffset: alueSize: src: 14861:6:1declaration: 532isSlot: isOffset: alueSize: src: 14936:6:1declaration: 532isSlot: isOffset: alueSize: src: 14990:6:1declaration: 532isSlot: isOffset: alueSize: src: 15049:6:1declaration: 532isSlot: isOffset: alueSize: src: 15117:6:1declaration: 532isSlot: isOffset: alueSize: src: 15186:6:1declaration: 532isSlot: isOffset: alueSize: src: 15256:6:1declaration: 532isSlot: isOffset: alueSize: src: 15327:6:1declaration: 532isSlot: isOffset: alueSize: src: 15399:6:1declaration: 532isSlot: isOffset: alueSize: src: 15472:6:1declaration: 532isSlot: isOffset: alueSize: src: 15546:6:1declaration: 532isSlot: isOffset: alueSize: src: 15621:6:1declaration: 532isSlot: isOffset: alueSize: src: 15698:6:1declaration: 532isSlot: isOffset: alueSize: src: 15776:6:1declaration: 532isSlot: isOffset: alueSize: src: 15855:6:1declaration: 532isSlot: isOffset: alueSize: src: 15935:6:1declaration: 532isSlot: isOffset: alueSize: src: 16016:6:1declaration: 532isSlot: isOffset: alueSize: src: 16098:6:1declaration: 532isSlot: isOffset: alueSize: src: 16181:6:1declaration: 532isSlot: isOffset: alueSize: src: 16265:6:1declaration: 532isSlot: isOffset: alueSize: src: 16350:6:1declaration: 532isSlot: isOffset: alueSize: src: 16436:6:1declaration: 532isSlot: isOffset: alueSize: src: 16523:6:1declaration: 532isSlot: isOffset: alueSize: src: 16611:6:1declaration: 532isSlot: isOffset: alueSize: src: 16700:6:1declaration: 532isSlot: isOffset: alueSize: src: 16790:6:1declaration: 532isSlot: isOffset: alueSize: src: 16881:6:1declaration: 532isSlot: isOffset: alueSize: src: 16973:6:1declaration: 532isSlot: isOffset: alueSize: src: 17066:6:1declaration: 532isSlot: isOffset: alueSize: src: 17160:6:1declaration: 532isSlot: isOffset: alueSize: src: 17255:6:1declaration: 532isSlot: isOffset: alueSize: src: 17351:6:1declaration: 532isSlot: isOffset: alueSize: src: 17448:6:1declaration: 532isSlot: isOffset: alueSize: src: 17546:6:1declaration: 532isSlot: isOffset: alueSize: src: 17645:6:1declaration: 532isSlot: isOffset: alueSize: src: 17745:6:1declaration: 532isSlot: isOffset: alueSize: src: 17846:6:1declaration: 532isSlot: isOffset: alueSize: src: 17948:6:1declaration: 532isSlot: isOffset: alueSize: src: 18051:6:1declaration: 532isSlot: isOffset: alueSize: src: 18155:6:1declaration: 532isSlot: isOffset: alueSize: src: 18260:6:1declaration: 532isSlot: isOffset: alueSize: src: 18366:6:1declaration: 532isSlot: isOffset: alueSize: src: 18473:6:1declaration: 532isSlot: isOffset: alueSize: src: 18581:6:1declaration: 532isSlot: isOffset: alueSize: src: 18690:6:1declaration: 532isSlot: isOffset: alueSize: src: 18800:6:1declaration: 532isSlot: isOffset: alueSize: src: 18911:6:1declaration: 532isSlot: isOffset: alueSize: src: 19023:6:1declaration: 532isSlot: isOffset: alueSize: src: 19136:6:1declaration: 532isSlot: isOffset: alueSize: src: 19250:6:1declaration: 532isSlot: isOffset: alueSize: src: 19365:6:1declaration: 532isSlot: isOffset: alueSize: src: 19481:6:1declaration: 532isSlot: isOffset: alueSize: src: 19598:6:1declaration: 532isSlot: isOffset: alueSize: src: 19716:6:1declaration: 532isSlot: isOffset: alueSize: src: 19835:6:1declaration: 532isSlot: isOffset: alueSize: src: 19955:6:1declaration: 532isSlot: isOffset: alueSize: src: 20076:6:1declaration: 532isSlot: isOffset: alueSize: src: 20198:6:1declaration: 532isSlot: isOffset: alueSize: src: 20321:6:1declaration: 532isSlot: isOffset: alueSize: src: 20445:6:1declaration: 532isSlot: isOffset: alueSize: src: 20510:6:1declaration: 532isSlot: isOffset: alueSize: src: 13726:1:1declaration: 529isSlot: isOffset: alueSize: 
evmVersion: cancun
 in
      let _ :=
        if M.bin_op (|
          "==",
          M.get_name (| "result" |),
          M.get_name (| "MAX_SD59x18" |)
        |) then
          let _ :=
            let _ :=
              M.assign (|
                "=",
                M.get_name (| "result" |),
                M.bin_op (|
                  "/",
                  Value.Tuple [
                    M.bin_op (|
                      "*",
                      M.call (|
                        M.get_name (| "log2" |),
                        [
                          M.get_name (| "x" |)
                        ]
                      |),
                      M.get_name (| "SCALE" |)
                    |)
                  ],
                  Value.Integer 332192809488736234
                |)
              |) in
            Value.Tuple [] in
          Value.Tuple []
        else
          Value.Tuple [] in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition log2 (α : list Value.t) : M :=
    match α with
    | [x] =>
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              ">",
              M.get_name (| "x" |),
              Value.Integer 0
            |)
          ]
        |) in
      let _ :=
        let _ :=
          M.define (|
            [ "sign" ],
            Value.Default
          |) in
        let _ :=
          if M.bin_op (|
            ">=",
            M.get_name (| "x" |),
            M.get_name (| "SCALE" |)
          |) then
            let _ :=
              M.assign (|
                "=",
                M.get_name (| "sign" |),
                Value.Integer 1
              |) in
            Value.Tuple []
          else
            let _ :=
              M.assign (|
                "=",
                M.get_name (| "sign" |),
                M.un_op (|
                  true,
                  "-",
                  Value.Integer 1
                |)
              |) in
            let _ :=
              (* Beginning of a node! *)
id: 589
src: 21818:99:1
nodeType: InlineAssembly
AST: TODO YulJson
externalReferences: src: 21849:1:1declaration: 562isSlot: isOffset: alueSize: src: 21897:1:1declaration: 562isSlot: isOffset: alueSize: 
evmVersion: cancun
 in
            Value.Tuple [] in
        let _ :=
          M.define (|
            [ "n" ],
            M.call (|
              M.member_access (|
                M.get_name (| "PRBMathCommon" |),
                "mostSignificantBit"
              |),
              [
                M.call (|
                  Ty.path "uint256",
                  [
                    M.bin_op (|
                      "/",
                      M.get_name (| "x" |),
                      M.get_name (| "SCALE" |)
                    |)
                  ]
                |)
              ]
            |)
          |) in
        let _ :=
          M.assign (|
            "=",
            M.get_name (| "result" |),
            M.bin_op (|
              "*",
              M.call (|
                Ty.path "int256",
                [
                  M.get_name (| "n" |)
                ]
              |),
              M.get_name (| "SCALE" |)
            |)
          |) in
        let _ :=
          M.define (|
            [ "y" ],
            M.bin_op (|
              ">>",
              M.get_name (| "x" |),
              M.get_name (| "n" |)
            |)
          |) in
        let _ :=
          if M.bin_op (|
            "==",
            M.get_name (| "y" |),
            M.get_name (| "SCALE" |)
          |) then
            let _ :=
              M.return_ (|
                M.bin_op (|
                  "*",
                  M.get_name (| "result" |),
                  M.get_name (| "sign" |)
                |)
              |) in
            Value.Tuple []
          else
            Value.Tuple [] in
        let _ :=
          M.for_ (|
            M.define (|
              [ "delta" ],
              M.call (|
                Ty.path "int256",
                [
                  M.get_name (| "HALF_SCALE" |)
                ]
              |)
            |),
            M.bin_op (|
              ">",
              M.get_name (| "delta" |),
              Value.Integer 0
            |),
            M.assign (|
              ">>=",
              M.get_name (| "delta" |),
              Value.Integer 1
            |),
            let _ :=
              M.assign (|
                "=",
                M.get_name (| "y" |),
                M.bin_op (|
                  "/",
                  Value.Tuple [
                    M.bin_op (|
                      "*",
                      M.get_name (| "y" |),
                      M.get_name (| "y" |)
                    |)
                  ],
                  M.get_name (| "SCALE" |)
                |)
              |) in
            let _ :=
              if M.bin_op (|
                ">=",
                M.get_name (| "y" |),
                M.bin_op (|
                  "*",
                  Value.Integer 2,
                  M.get_name (| "SCALE" |)
                |)
              |) then
                let _ :=
                  M.assign (|
                    "+=",
                    M.get_name (| "result" |),
                    M.get_name (| "delta" |)
                  |) in
                let _ :=
                  M.assign (|
                    ">>=",
                    M.get_name (| "y" |),
                    Value.Integer 1
                  |) in
                Value.Tuple []
              else
                Value.Tuple [] in
            Value.Tuple []
          |) in
        let _ :=
          M.assign (|
            "*=",
            M.get_name (| "result" |),
            M.get_name (| "sign" |)
          |) in
        Value.Tuple [] in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition mul (α : list Value.t) : M :=
    match α with
    | [x, y] =>
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              ">",
              M.get_name (| "x" |),
              M.get_name (| "MIN_SD59x18" |)
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              ">",
              M.get_name (| "y" |),
              M.get_name (| "MIN_SD59x18" |)
            |)
          ]
        |) in
      let _ :=
        let _ :=
          M.define (|
            [ "ax" ],
            Value.Default
          |) in
        let _ :=
          M.define (|
            [ "ay" ],
            Value.Default
          |) in
        let _ :=
          M.assign (|
            "=",
            M.get_name (| "ax" |),
            Conditional M.bin_op (|
              "<",
              M.get_name (| "x" |),
              Value.Integer 0
            |) M.call (|
              Ty.path "uint256",
              [
                M.un_op (|
                  true,
                  "-",
                  M.get_name (| "x" |)
                |)
              ]
            |) M.call (|
              Ty.path "uint256",
              [
                M.get_name (| "x" |)
              ]
            |)

          |) in
        let _ :=
          M.assign (|
            "=",
            M.get_name (| "ay" |),
            Conditional M.bin_op (|
              "<",
              M.get_name (| "y" |),
              Value.Integer 0
            |) M.call (|
              Ty.path "uint256",
              [
                M.un_op (|
                  true,
                  "-",
                  M.get_name (| "y" |)
                |)
              ]
            |) M.call (|
              Ty.path "uint256",
              [
                M.get_name (| "y" |)
              ]
            |)

          |) in
        let _ :=
          M.define (|
            [ "resultUnsigned" ],
            M.call (|
              M.member_access (|
                M.get_name (| "PRBMathCommon" |),
                "mulDivFixedPoint"
              |),
              [
                M.get_name (| "ax" |),
                M.get_name (| "ay" |)
              ]
            |)
          |) in
        let _ :=
          M.call (|
            M.get_name (| "require" |),
            [
              M.bin_op (|
                "<=",
                M.get_name (| "resultUnsigned" |),
                M.call (|
                  Ty.path "uint256",
                  [
                    M.get_name (| "MAX_SD59x18" |)
                  ]
                |)
              |)
            ]
          |) in
        let _ :=
          M.define (|
            [ "sx" ],
            Value.Default
          |) in
        let _ :=
          M.define (|
            [ "sy" ],
            Value.Default
          |) in
        let _ :=
          (* Beginning of a node! *)
id: 757
src: 24585:104:1
nodeType: InlineAssembly
AST: TODO YulJson
externalReferences: src: 24612:2:1declaration: 752isSlot: isOffset: alueSize: src: 24652:2:1declaration: 755isSlot: isOffset: alueSize: src: 24622:1:1declaration: 677isSlot: isOffset: alueSize: src: 24662:1:1declaration: 679isSlot: isOffset: alueSize: 
evmVersion: cancun
 in
        let _ :=
          M.assign (|
            "=",
            M.get_name (| "result" |),
            Conditional M.bin_op (|
              "==",
              M.bin_op (|
                "^",
                M.get_name (| "sx" |),
                M.get_name (| "sy" |)
              |),
              Value.Integer 1
            |) M.un_op (|
              true,
              "-",
              M.call (|
                Ty.path "int256",
                [
                  M.get_name (| "resultUnsigned" |)
                ]
              |)
            |) M.call (|
              Ty.path "int256",
              [
                M.get_name (| "resultUnsigned" |)
              ]
            |)

          |) in
        Value.Tuple [] in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition pi (α : list Value.t) : M :=
    match α with
    | [] =>
      let _ :=
        M.assign (|
          "=",
          M.get_name (| "result" |),
          Value.Integer 3141592653589793238
        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition pow (α : list Value.t) : M :=
    match α with
    | [x, y] =>
      let _ :=
        M.define (|
          [ "absX" ],
          M.call (|
            Ty.path "uint256",
            [
              M.call (|
                M.get_name (| "abs" |),
                [
                  M.get_name (| "x" |)
                ]
              |)
            ]
          |)
        |) in
      let _ :=
        M.define (|
          [ "absResult" ],
          Conditional M.bin_op (|
            ">",
            M.bin_op (|
              "&",
              M.get_name (| "y" |),
              Value.Integer 1
            |),
            Value.Integer 0
          |) M.get_name (| "absX" |) M.call (|
            Ty.path "uint256",
            [
              M.get_name (| "SCALE" |)
            ]
          |)

        |) in
      let _ :=
        M.for_ (|
          M.assign (|
            ">>=",
            M.get_name (| "y" |),
            Value.Integer 1
          |),
          M.bin_op (|
            ">",
            M.get_name (| "y" |),
            Value.Integer 0
          |),
          M.assign (|
            ">>=",
            M.get_name (| "y" |),
            Value.Integer 1
          |),
          let _ :=
            M.assign (|
              "=",
              M.get_name (| "absX" |),
              M.call (|
                M.member_access (|
                  M.get_name (| "PRBMathCommon" |),
                  "mulDivFixedPoint"
                |),
                [
                  M.get_name (| "absX" |),
                  M.get_name (| "absX" |)
                ]
              |)
            |) in
          let _ :=
            if M.bin_op (|
              ">",
              M.bin_op (|
                "&",
                M.get_name (| "y" |),
                Value.Integer 1
              |),
              Value.Integer 0
            |) then
              let _ :=
                M.assign (|
                  "=",
                  M.get_name (| "absResult" |),
                  M.call (|
                    M.member_access (|
                      M.get_name (| "PRBMathCommon" |),
                      "mulDivFixedPoint"
                    |),
                    [
                      M.get_name (| "absResult" |),
                      M.get_name (| "absX" |)
                    ]
                  |)
                |) in
              Value.Tuple []
            else
              Value.Tuple [] in
          Value.Tuple []
        |) in
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              "<=",
              M.get_name (| "absResult" |),
              M.call (|
                Ty.path "uint256",
                [
                  M.get_name (| "MAX_SD59x18" |)
                ]
              |)
            |)
          ]
        |) in
      let _ :=
        M.define (|
          [ "isNegative" ],
          M.bin_op (|
            "&&",
            M.bin_op (|
              "<",
              M.get_name (| "x" |),
              Value.Integer 0
            |),
            M.bin_op (|
              "==",
              M.bin_op (|
                "&",
                M.get_name (| "y" |),
                Value.Integer 1
              |),
              Value.Integer 1
            |)
          |)
        |) in
      let _ :=
        M.assign (|
          "=",
          M.get_name (| "result" |),
          Conditional M.get_name (| "isNegative" |) M.un_op (|
            true,
            "-",
            M.call (|
              Ty.path "int256",
              [
                M.get_name (| "absResult" |)
              ]
            |)
          |) M.call (|
            Ty.path "int256",
            [
              M.get_name (| "absResult" |)
            ]
          |)

        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition scale (α : list Value.t) : M :=
    match α with
    | [] =>
      let _ :=
        M.assign (|
          "=",
          M.get_name (| "result" |),
          M.get_name (| "SCALE" |)
        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition sqrt (α : list Value.t) : M :=
    match α with
    | [x] =>
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              ">=",
              M.get_name (| "x" |),
              Value.Integer 0
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              "<",
              M.get_name (| "x" |),
              Value.Integer 57896044618658097711785492504343953926634992332820282019729
            |)
          ]
        |) in
      let _ :=
        let _ :=
          M.assign (|
            "=",
            M.get_name (| "result" |),
            M.call (|
              Ty.path "int256",
              [
                M.call (|
                  M.member_access (|
                    M.get_name (| "PRBMathCommon" |),
                    "sqrt"
                  |),
                  [
                    M.call (|
                      Ty.path "uint256",
                      [
                        M.bin_op (|
                          "*",
                          M.get_name (| "x" |),
                          M.get_name (| "SCALE" |)
                        |)
                      ]
                    |)
                  ]
                |)
              ]
            |)
          |) in
        Value.Tuple [] in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.
End PRBMathSD59x18.
