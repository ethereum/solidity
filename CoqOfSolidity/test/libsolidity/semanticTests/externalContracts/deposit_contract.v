(* Generated by coq-of-solidity *)
Require Import CoqOfSolidity.CoqOfSolidity.

(* License: CC0-1.0 *)

(* Interface *)
Module IDepositContract.
  (* Event DepositEvent *)

  Definition deposit (α : list Value.t) : M :=
    match α with
    | [pubkey, withdrawal_credentials, signature, deposit_data_root] =>
      not implemented
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition get_deposit_root (α : list Value.t) : M :=
    match α with
    | [] =>
      not implemented
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition get_deposit_count (α : list Value.t) : M :=
    match α with
    | [] =>
      not implemented
    | _ => M.impossible "invalid number of parameters"
    end.
End IDepositContract.


(* Interface *)
Module ERC165.
  Definition supportsInterface (α : list Value.t) : M :=
    match α with
    | [interfaceId] =>
      not implemented
    | _ => M.impossible "invalid number of parameters"
    end.
End ERC165.


(* Contract *)
Module DepositContract.
  Definition DEPOSIT_CONTRACT_TREE_DEPTH : Value.t :=
    Value.Integer 32.

  Definition MAX_DEPOSIT_COUNT : Value.t :=
    M.bin_op (|
      "-",
      M.bin_op (|
        "**",
        Value.Integer 2,
        M.get_name (| "DEPOSIT_CONTRACT_TREE_DEPTH" |)
      |),
      Value.Integer 1
    |).

  Definition branch : Value.t :=
    undefined.

  Definition deposit_count : Value.t :=
    undefined.

  Definition zero_hashes : Value.t :=
    undefined.

  Definition  (α : list Value.t) : M :=
    match α with
    | [] =>
      let _ :=
        M.for_ (|
          M.define (|
            [ "height" ],
            Value.Integer 0
          |),
          M.bin_op (|
            "<",
            M.get_name (| "height" |),
            M.bin_op (|
              "-",
              M.get_name (| "DEPOSIT_CONTRACT_TREE_DEPTH" |),
              Value.Integer 1
            |)
          |),
          M.un_op (|
            false,
            "++",
            M.get_name (| "height" |)
          |),
          M.assign (|
            "=",
            M.index_access (|
              M.get_name (| "zero_hashes" |),
              Some (M.bin_op (|
                "+",
                M.get_name (| "height" |),
                Value.Integer 1
              |))
            |),
            M.call (|
              M.get_name (| "sha256" |),
              [
                M.call (|
                  M.member_access (|
                    M.get_name (| "abi" |),
                    "encodePacked"
                  |),
                  [
                    M.index_access (|
                      M.get_name (| "zero_hashes" |),
                      Some (M.get_name (| "height" |))
                    |),
                    M.index_access (|
                      M.get_name (| "zero_hashes" |),
                      Some (M.get_name (| "height" |))
                    |)
                  ]
                |)
              ]
            |)
          |)
        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition get_deposit_root (α : list Value.t) : M :=
    match α with
    | [] =>
      let _ :=
        M.define (|
          [ "node" ],
          Value.Default
        |) in
      let _ :=
        M.define (|
          [ "size" ],
          M.get_name (| "deposit_count" |)
        |) in
      let _ :=
        M.for_ (|
          M.define (|
            [ "height" ],
            Value.Integer 0
          |),
          M.bin_op (|
            "<",
            M.get_name (| "height" |),
            M.get_name (| "DEPOSIT_CONTRACT_TREE_DEPTH" |)
          |),
          M.un_op (|
            false,
            "++",
            M.get_name (| "height" |)
          |),
          let _ :=
            if M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  "&",
                  M.get_name (| "size" |),
                  Value.Integer 1
                |)
              ],
              Value.Integer 1
            |) then
              M.assign (|
                "=",
                M.get_name (| "node" |),
                M.call (|
                  M.get_name (| "sha256" |),
                  [
                    M.call (|
                      M.member_access (|
                        M.get_name (| "abi" |),
                        "encodePacked"
                      |),
                      [
                        M.index_access (|
                          M.get_name (| "branch" |),
                          Some (M.get_name (| "height" |))
                        |),
                        M.get_name (| "node" |)
                      ]
                    |)
                  ]
                |)
              |)
            else
              M.assign (|
                "=",
                M.get_name (| "node" |),
                M.call (|
                  M.get_name (| "sha256" |),
                  [
                    M.call (|
                      M.member_access (|
                        M.get_name (| "abi" |),
                        "encodePacked"
                      |),
                      [
                        M.get_name (| "node" |),
                        M.index_access (|
                          M.get_name (| "zero_hashes" |),
                          Some (M.get_name (| "height" |))
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
          let _ :=
            M.assign (|
              "/=",
              M.get_name (| "size" |),
              Value.Integer 2
            |) in
          Value.Tuple []
        |) in
      let _ :=
        M.return_ (|
          M.call (|
            M.get_name (| "sha256" |),
            [
              M.call (|
                M.member_access (|
                  M.get_name (| "abi" |),
                  "encodePacked"
                |),
                [
                  M.get_name (| "node" |),
                  M.call (|
                    M.get_name (| "to_little_endian_64" |),
                    [
                      M.call (|
                        Ty.path "uint64",
                        [
                          M.get_name (| "deposit_count" |)
                        ]
                      |)
                    ]
                  |),
                  M.call (|
                    Ty.path "bytes24",
                    [
                      Value.Integer 0
                    ]
                  |)
                ]
              |)
            ]
          |)
        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition get_deposit_count (α : list Value.t) : M :=
    match α with
    | [] =>
      let _ :=
        M.return_ (|
          M.call (|
            M.get_name (| "to_little_endian_64" |),
            [
              M.call (|
                Ty.path "uint64",
                [
                  M.get_name (| "deposit_count" |)
                ]
              |)
            ]
          |)
        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition deposit (α : list Value.t) : M :=
    match α with
    | [pubkey, withdrawal_credentials, signature, deposit_data_root] =>
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              "==",
              M.member_access (|
                M.get_name (| "pubkey" |),
                "length"
              |),
              Value.Integer 48
            |),
            Value.String "DepositContract: invalid pubkey length"
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              "==",
              M.member_access (|
                M.get_name (| "withdrawal_credentials" |),
                "length"
              |),
              Value.Integer 32
            |),
            Value.String "DepositContract: invalid withdrawal_credentials length"
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              "==",
              M.member_access (|
                M.get_name (| "signature" |),
                "length"
              |),
              Value.Integer 96
            |),
            Value.String "DepositContract: invalid signature length"
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              ">=",
              M.member_access (|
                M.get_name (| "msg" |),
                "value"
              |),
              Value.Integer 1
            |),
            Value.String "DepositContract: deposit value too low"
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              "==",
              M.bin_op (|
                "%",
                M.member_access (|
                  M.get_name (| "msg" |),
                  "value"
                |),
                Value.Integer 1
              |),
              Value.Integer 0
            |),
            Value.String "DepositContract: deposit value not multiple of gwei"
          ]
        |) in
      let _ :=
        M.define (|
          [ "deposit_amount" ],
          M.bin_op (|
            "/",
            M.member_access (|
              M.get_name (| "msg" |),
              "value"
            |),
            Value.Integer 1
          |)
        |) in
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              "<=",
              M.get_name (| "deposit_amount" |),
              M.member_access (|
                M.call (|
                  M.get_name (| "type" |),
                  [
                    Ty.path "uint64"
                  ]
                |),
                "max"
              |)
            |),
            Value.String "DepositContract: deposit value too high"
          ]
        |) in
      let _ :=
        M.define (|
          [ "amount" ],
          M.call (|
            M.get_name (| "to_little_endian_64" |),
            [
              M.call (|
                Ty.path "uint64",
                [
                  M.get_name (| "deposit_amount" |)
                ]
              |)
            ]
          |)
        |) in
      let _ :=
        EmitStatement M.call (|
          M.get_name (| "DepositEvent" |),
          [
            M.get_name (| "pubkey" |),
            M.get_name (| "withdrawal_credentials" |),
            M.get_name (| "amount" |),
            M.get_name (| "signature" |),
            M.call (|
              M.get_name (| "to_little_endian_64" |),
              [
                M.call (|
                  Ty.path "uint64",
                  [
                    M.get_name (| "deposit_count" |)
                  ]
                |)
              ]
            |)
          ]
        |)
 in
      let _ :=
        M.define (|
          [ "pubkey_root" ],
          M.call (|
            M.get_name (| "sha256" |),
            [
              M.call (|
                M.member_access (|
                  M.get_name (| "abi" |),
                  "encodePacked"
                |),
                [
                  M.get_name (| "pubkey" |),
                  M.call (|
                    Ty.path "bytes16",
                    [
                      Value.Integer 0
                    ]
                  |)
                ]
              |)
            ]
          |)
        |) in
      let _ :=
        M.define (|
          [ "signature_root" ],
          M.call (|
            M.get_name (| "sha256" |),
            [
              M.call (|
                M.member_access (|
                  M.get_name (| "abi" |),
                  "encodePacked"
                |),
                [
                  M.call (|
                    M.get_name (| "sha256" |),
                    [
                      M.call (|
                        M.member_access (|
                          M.get_name (| "abi" |),
                          "encodePacked"
                        |),
                        [
                          IndexRangeAccess M.get_name (| "signature" |)  Value.Integer 64

                        ]
                      |)
                    ]
                  |),
                  M.call (|
                    M.get_name (| "sha256" |),
                    [
                      M.call (|
                        M.member_access (|
                          M.get_name (| "abi" |),
                          "encodePacked"
                        |),
                        [
                          IndexRangeAccess M.get_name (| "signature" |) Value.Integer 64 
,
                          M.call (|
                            Ty.path "bytes32",
                            [
                              Value.Integer 0
                            ]
                          |)
                        ]
                      |)
                    ]
                  |)
                ]
              |)
            ]
          |)
        |) in
      let _ :=
        M.define (|
          [ "node" ],
          M.call (|
            M.get_name (| "sha256" |),
            [
              M.call (|
                M.member_access (|
                  M.get_name (| "abi" |),
                  "encodePacked"
                |),
                [
                  M.call (|
                    M.get_name (| "sha256" |),
                    [
                      M.call (|
                        M.member_access (|
                          M.get_name (| "abi" |),
                          "encodePacked"
                        |),
                        [
                          M.get_name (| "pubkey_root" |),
                          M.get_name (| "withdrawal_credentials" |)
                        ]
                      |)
                    ]
                  |),
                  M.call (|
                    M.get_name (| "sha256" |),
                    [
                      M.call (|
                        M.member_access (|
                          M.get_name (| "abi" |),
                          "encodePacked"
                        |),
                        [
                          M.get_name (| "amount" |),
                          M.call (|
                            Ty.path "bytes24",
                            [
                              Value.Integer 0
                            ]
                          |),
                          M.get_name (| "signature_root" |)
                        ]
                      |)
                    ]
                  |)
                ]
              |)
            ]
          |)
        |) in
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              "==",
              M.get_name (| "node" |),
              M.get_name (| "deposit_data_root" |)
            |),
            Value.String "DepositContract: reconstructed DepositData does not match supplied deposit_data_root"
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "require" |),
          [
            M.bin_op (|
              "<",
              M.get_name (| "deposit_count" |),
              M.get_name (| "MAX_DEPOSIT_COUNT" |)
            |),
            Value.String "DepositContract: merkle tree full"
          ]
        |) in
      let _ :=
        M.assign (|
          "+=",
          M.get_name (| "deposit_count" |),
          Value.Integer 1
        |) in
      let _ :=
        M.define (|
          [ "size" ],
          M.get_name (| "deposit_count" |)
        |) in
      let _ :=
        M.for_ (|
          M.define (|
            [ "height" ],
            Value.Integer 0
          |),
          M.bin_op (|
            "<",
            M.get_name (| "height" |),
            M.get_name (| "DEPOSIT_CONTRACT_TREE_DEPTH" |)
          |),
          M.un_op (|
            false,
            "++",
            M.get_name (| "height" |)
          |),
          let _ :=
            if M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  "&",
                  M.get_name (| "size" |),
                  Value.Integer 1
                |)
              ],
              Value.Integer 1
            |) then
              let _ :=
                M.assign (|
                  "=",
                  M.index_access (|
                    M.get_name (| "branch" |),
                    Some (M.get_name (| "height" |))
                  |),
                  M.get_name (| "node" |)
                |) in
              let _ :=
                M.return_ (|
                  Value.Tuple []
                |) in
              Value.Tuple []
            else
              Value.Tuple [] in
          let _ :=
            M.assign (|
              "=",
              M.get_name (| "node" |),
              M.call (|
                M.get_name (| "sha256" |),
                [
                  M.call (|
                    M.member_access (|
                      M.get_name (| "abi" |),
                      "encodePacked"
                    |),
                    [
                      M.index_access (|
                        M.get_name (| "branch" |),
                        Some (M.get_name (| "height" |))
                      |),
                      M.get_name (| "node" |)
                    ]
                  |)
                ]
              |)
            |) in
          let _ :=
            M.assign (|
              "/=",
              M.get_name (| "size" |),
              Value.Integer 2
            |) in
          Value.Tuple []
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            Value.Bool false
          ]
        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition supportsInterface (α : list Value.t) : M :=
    match α with
    | [interfaceId] =>
      let _ :=
        M.return_ (|
          M.bin_op (|
            "||",
            M.bin_op (|
              "==",
              M.get_name (| "interfaceId" |),
              M.member_access (|
                M.call (|
                  M.get_name (| "type" |),
                  [
                    M.get_name (| "ERC165" |)
                  ]
                |),
                "interfaceId"
              |)
            |),
            M.bin_op (|
              "==",
              M.get_name (| "interfaceId" |),
              M.member_access (|
                M.call (|
                  M.get_name (| "type" |),
                  [
                    M.get_name (| "IDepositContract" |)
                  ]
                |),
                "interfaceId"
              |)
            |)
          |)
        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition to_little_endian_64 (α : list Value.t) : M :=
    match α with
    | [value] =>
      let _ :=
        M.assign (|
          "=",
          M.get_name (| "ret" |),
          M.call (|
            NewExpression Ty.path "bytes"
,
            [
              Value.Integer 8
            ]
          |)
        |) in
      let _ :=
        M.define (|
          [ "bytesValue" ],
          M.call (|
            Ty.path "bytes8",
            [
              M.get_name (| "value" |)
            ]
          |)
        |) in
      let _ :=
        M.assign (|
          "=",
          M.index_access (|
            M.get_name (| "ret" |),
            Some (Value.Integer 0)
          |),
          M.index_access (|
            M.get_name (| "bytesValue" |),
            Some (Value.Integer 7)
          |)
        |) in
      let _ :=
        M.assign (|
          "=",
          M.index_access (|
            M.get_name (| "ret" |),
            Some (Value.Integer 1)
          |),
          M.index_access (|
            M.get_name (| "bytesValue" |),
            Some (Value.Integer 6)
          |)
        |) in
      let _ :=
        M.assign (|
          "=",
          M.index_access (|
            M.get_name (| "ret" |),
            Some (Value.Integer 2)
          |),
          M.index_access (|
            M.get_name (| "bytesValue" |),
            Some (Value.Integer 5)
          |)
        |) in
      let _ :=
        M.assign (|
          "=",
          M.index_access (|
            M.get_name (| "ret" |),
            Some (Value.Integer 3)
          |),
          M.index_access (|
            M.get_name (| "bytesValue" |),
            Some (Value.Integer 4)
          |)
        |) in
      let _ :=
        M.assign (|
          "=",
          M.index_access (|
            M.get_name (| "ret" |),
            Some (Value.Integer 4)
          |),
          M.index_access (|
            M.get_name (| "bytesValue" |),
            Some (Value.Integer 3)
          |)
        |) in
      let _ :=
        M.assign (|
          "=",
          M.index_access (|
            M.get_name (| "ret" |),
            Some (Value.Integer 5)
          |),
          M.index_access (|
            M.get_name (| "bytesValue" |),
            Some (Value.Integer 2)
          |)
        |) in
      let _ :=
        M.assign (|
          "=",
          M.index_access (|
            M.get_name (| "ret" |),
            Some (Value.Integer 6)
          |),
          M.index_access (|
            M.get_name (| "bytesValue" |),
            Some (Value.Integer 1)
          |)
        |) in
      let _ :=
        M.assign (|
          "=",
          M.index_access (|
            M.get_name (| "ret" |),
            Some (Value.Integer 7)
          |),
          M.index_access (|
            M.get_name (| "bytesValue" |),
            Some (Value.Integer 0)
          |)
        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.
End DepositContract.
