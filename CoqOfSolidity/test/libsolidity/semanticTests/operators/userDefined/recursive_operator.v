(* Generated by coq-of-solidity *)
Require Import CoqOfSolidity.CoqOfSolidity.

Axiom user_type_Uint : Ty.path "Uint" = Ty.path "uint".

Axiom using : M.usingFunctions (|
    Some (Ty.path "Uint"),
    UsingKind.Global,
    [
    UsingFunction.Operator "~" "unaryCountdown",
    UsingFunction.Operator "^" "binaryCountdown",
    UsingFunction.Operator "==" "eq",
  ]
  |).

Definition unaryCountdown (α : list Value.t) : M :=
  match α with
  | [x] =>
    let _ :=
      if M.bin_op (|
        "==",
        M.get_name (| "x" |),
        M.call (|
          M.member_access (|
            M.get_name (| "Uint" |),
            "wrap"
          |),
          [
            Value.Integer 0
          ]
        |)
      |) then
        M.return_ (|
          M.call (|
            M.member_access (|
              M.get_name (| "Uint" |),
              "wrap"
            |),
            [
              Value.Integer 0
            ]
          |)
        |)
      else
        Value.Tuple [] in
    let _ :=
      M.return_ (|
        M.un_op (|
          true,
          "~",
          M.call (|
            M.member_access (|
              M.get_name (| "Uint" |),
              "wrap"
            |),
            [
              M.bin_op (|
                "-",
                M.call (|
                  M.member_access (|
                    M.get_name (| "Uint" |),
                    "unwrap"
                  |),
                  [
                    M.get_name (| "x" |)
                  ]
                |),
                Value.Integer 1
              |)
            ]
          |)
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.

Definition binaryCountdown (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      if M.bin_op (|
        "&&",
        M.bin_op (|
          "==",
          M.get_name (| "x" |),
          M.call (|
            M.member_access (|
              M.get_name (| "Uint" |),
              "wrap"
            |),
            [
              Value.Integer 0
            ]
          |)
        |),
        M.bin_op (|
          "==",
          M.get_name (| "y" |),
          M.call (|
            M.member_access (|
              M.get_name (| "Uint" |),
              "wrap"
            |),
            [
              Value.Integer 0
            ]
          |)
        |)
      |) then
        M.return_ (|
          M.call (|
            M.member_access (|
              M.get_name (| "Uint" |),
              "wrap"
            |),
            [
              Value.Integer 0
            ]
          |)
        |)
      else
        Value.Tuple [] in
    let _ :=
      if M.bin_op (|
        "==",
        M.get_name (| "x" |),
        M.call (|
          M.member_access (|
            M.get_name (| "Uint" |),
            "wrap"
          |),
          [
            Value.Integer 0
          ]
        |)
      |) then
        M.return_ (|
          M.bin_op (|
            "^",
            M.get_name (| "y" |),
            M.get_name (| "x" |)
          |)
        |)
      else
        Value.Tuple [] in
    let _ :=
      M.return_ (|
        M.bin_op (|
          "^",
          M.call (|
            M.member_access (|
              M.get_name (| "Uint" |),
              "wrap"
            |),
            [
              M.bin_op (|
                "-",
                M.call (|
                  M.member_access (|
                    M.get_name (| "Uint" |),
                    "unwrap"
                  |),
                  [
                    M.get_name (| "x" |)
                  ]
                |),
                Value.Integer 1
              |)
            ]
          |),
          M.get_name (| "y" |)
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.

Definition eq (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.bin_op (|
          "==",
          M.call (|
            M.member_access (|
              M.get_name (| "Uint" |),
              "unwrap"
            |),
            [
              M.get_name (| "x" |)
            ]
          |),
          M.call (|
            M.member_access (|
              M.get_name (| "Uint" |),
              "unwrap"
            |),
            [
              M.get_name (| "y" |)
            ]
          |)
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.

(* Contract *)
Module C.
  Definition testUnary (α : list Value.t) : M :=
    match α with
    | [x] =>
      let _ :=
        M.return_ (|
          M.un_op (|
            true,
            "~",
            M.get_name (| "x" |)
          |)
        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition testBinary (α : list Value.t) : M :=
    match α with
    | [x, y] =>
      let _ :=
        M.return_ (|
          M.bin_op (|
            "^",
            M.get_name (| "x" |),
            M.get_name (| "y" |)
          |)
        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.
End C.
