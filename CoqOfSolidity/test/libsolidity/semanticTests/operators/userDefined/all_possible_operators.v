(* Generated by coq-of-solidity *)
Require Import CoqOfSolidity.CoqOfSolidity.

Axiom user_type_Int : Ty.path "Int" = Ty.path "int8".

Axiom using : M.usingFunctions (|
    Some (Ty.path "Int"),
    UsingKind.Global,
    [
    UsingFunction.Operator "|" "bitor",
    UsingFunction.Operator "&" "bitand",
    UsingFunction.Operator "^" "bitxor",
    UsingFunction.Operator "~" "bitnot",
    UsingFunction.Operator "+" "add",
    UsingFunction.Operator "-" "sub",
    UsingFunction.Operator "-" "unsub",
    UsingFunction.Operator "*" "mul",
    UsingFunction.Operator "/" "div",
    UsingFunction.Operator "%" "mod",
    UsingFunction.Operator "==" "eq",
    UsingFunction.Operator "!=" "noteq",
    UsingFunction.Operator "<" "lt",
    UsingFunction.Operator ">" "gt",
    UsingFunction.Operator "<=" "leq",
    UsingFunction.Operator ">=" "geq",
  ]
  |).

Definition bitor (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.bin_op (|
              "|",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |),
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "y" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.

Definition bitand (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.bin_op (|
              "&",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |),
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "y" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.

Definition bitxor (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.bin_op (|
              "^",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |),
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "y" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.

Definition bitnot (α : list Value.t) : M :=
  match α with
  | [x] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.un_op (|
              true,
              "~",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.

Definition add (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.bin_op (|
              "+",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |),
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "y" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.

Definition sub (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.bin_op (|
              "-",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |),
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "y" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.

Definition unsub (α : list Value.t) : M :=
  match α with
  | [x] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.un_op (|
              true,
              "-",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.

Definition mul (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.bin_op (|
              "*",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |),
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "y" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.

Definition div (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.bin_op (|
              "/",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |),
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "y" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.

Definition mod (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.bin_op (|
              "%",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |),
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "y" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.

Definition eq (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.bin_op (|
          "==",
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "x" |)
            ]
          |),
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "y" |)
            ]
          |)
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.

Definition noteq (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.bin_op (|
          "!=",
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "x" |)
            ]
          |),
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "y" |)
            ]
          |)
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.

Definition lt (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.bin_op (|
          "<",
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "x" |)
            ]
          |),
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "y" |)
            ]
          |)
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.

Definition gt (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.bin_op (|
          ">",
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "x" |)
            ]
          |),
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "y" |)
            ]
          |)
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.

Definition leq (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.bin_op (|
          "<=",
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "x" |)
            ]
          |),
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "y" |)
            ]
          |)
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.

Definition geq (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.bin_op (|
          ">=",
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "x" |)
            ]
          |),
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "y" |)
            ]
          |)
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.

(* Contract *)
Module C.
  Definition ZERO : Value.t :=
    M.call (|
      M.member_access (|
        M.get_name (| "Int" |),
        "wrap"
      |),
      [
        Value.Integer 0
      ]
    |).

  Definition ONE : Value.t :=
    M.call (|
      M.member_access (|
        M.get_name (| "Int" |),
        "wrap"
      |),
      [
        Value.Integer 1
      ]
    |).

  Definition TWO : Value.t :=
    M.call (|
      M.member_access (|
        M.get_name (| "Int" |),
        "wrap"
      |),
      [
        Value.Integer 2
      ]
    |).

  Definition THREE : Value.t :=
    M.call (|
      M.member_access (|
        M.get_name (| "Int" |),
        "wrap"
      |),
      [
        Value.Integer 3
      ]
    |).

  Definition SIX : Value.t :=
    M.call (|
      M.member_access (|
        M.get_name (| "Int" |),
        "wrap"
      |),
      [
        Value.Integer 6
      ]
    |).

  Definition testBitwise (α : list Value.t) : M :=
    match α with
    | [] =>
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "|",
                    M.get_name (| "ONE" |),
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              Value.Integer 3
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "|",
                    M.get_name (| "ONE" |),
                    M.get_name (| "ZERO" |)
                  |)
                ]
              |),
              Value.Integer 1
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "&",
                    M.get_name (| "ONE" |),
                    M.get_name (| "THREE" |)
                  |)
                ]
              |),
              Value.Integer 1
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "&",
                    M.get_name (| "ONE" |),
                    M.get_name (| "ONE" |)
                  |)
                ]
              |),
              Value.Integer 1
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "^",
                    M.get_name (| "TWO" |),
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              Value.Integer 0
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "^",
                    M.get_name (| "TWO" |),
                    M.get_name (| "ONE" |)
                  |)
                ]
              |),
              Value.Integer 3
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.un_op (|
                    true,
                    "~",
                    M.get_name (| "ZERO" |)
                  |)
                ]
              |),
              M.un_op (|
                true,
                "-",
                Value.Integer 1
              |)
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.un_op (|
                    true,
                    "~",
                    M.get_name (| "ONE" |)
                  |)
                ]
              |),
              M.un_op (|
                true,
                "-",
                Value.Integer 2
              |)
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.un_op (|
                    true,
                    "~",
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              M.un_op (|
                true,
                "-",
                Value.Integer 3
              |)
            |)
          ]
        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition testArithmetic (α : list Value.t) : M :=
    match α with
    | [] =>
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "+",
                    M.get_name (| "ONE" |),
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              Value.Integer 3
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "+",
                    M.get_name (| "ONE" |),
                    M.get_name (| "ZERO" |)
                  |)
                ]
              |),
              Value.Integer 1
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "-",
                    M.get_name (| "TWO" |),
                    M.get_name (| "ONE" |)
                  |)
                ]
              |),
              Value.Integer 1
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "-",
                    M.get_name (| "THREE" |),
                    M.get_name (| "THREE" |)
                  |)
                ]
              |),
              Value.Integer 0
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.un_op (|
                    true,
                    "-",
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              M.un_op (|
                true,
                "-",
                Value.Integer 2
              |)
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.un_op (|
                    true,
                    "-",
                    M.get_name (| "ZERO" |)
                  |)
                ]
              |),
              Value.Integer 0
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "*",
                    M.get_name (| "ONE" |),
                    M.get_name (| "ONE" |)
                  |)
                ]
              |),
              Value.Integer 1
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "*",
                    M.get_name (| "THREE" |),
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              Value.Integer 6
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "/",
                    M.get_name (| "SIX" |),
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              Value.Integer 3
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "/",
                    M.get_name (| "THREE" |),
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              Value.Integer 1
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "%",
                    M.get_name (| "SIX" |),
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              Value.Integer 0
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "%",
                    M.get_name (| "THREE" |),
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              Value.Integer 1
            |)
          ]
        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition testComparison (α : list Value.t) : M :=
    match α with
    | [] =>
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  "==",
                  M.get_name (| "ONE" |),
                  M.get_name (| "ONE" |)
                |)
              ],
              Value.Bool true
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  "==",
                  M.get_name (| "ONE" |),
                  M.get_name (| "TWO" |)
                |)
              ],
              Value.Bool false
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  "!=",
                  M.get_name (| "ONE" |),
                  M.get_name (| "ONE" |)
                |)
              ],
              Value.Bool false
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  "!=",
                  M.get_name (| "ONE" |),
                  M.get_name (| "TWO" |)
                |)
              ],
              Value.Bool true
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  "<",
                  M.get_name (| "ONE" |),
                  M.get_name (| "TWO" |)
                |)
              ],
              Value.Bool true
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  "<",
                  M.get_name (| "TWO" |),
                  M.get_name (| "ONE" |)
                |)
              ],
              Value.Bool false
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  "<=",
                  M.get_name (| "ONE" |),
                  M.get_name (| "TWO" |)
                |)
              ],
              Value.Bool true
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  "<=",
                  M.get_name (| "TWO" |),
                  M.get_name (| "ONE" |)
                |)
              ],
              Value.Bool false
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  ">",
                  M.get_name (| "ONE" |),
                  M.get_name (| "TWO" |)
                |)
              ],
              Value.Bool false
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  ">",
                  M.get_name (| "TWO" |),
                  M.get_name (| "ONE" |)
                |)
              ],
              Value.Bool true
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  ">=",
                  M.get_name (| "ONE" |),
                  M.get_name (| "TWO" |)
                |)
              ],
              Value.Bool false
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  ">=",
                  M.get_name (| "TWO" |),
                  M.get_name (| "ONE" |)
                |)
              ],
              Value.Bool true
            |)
          ]
        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.
End C.
