{"contracts":{"A":{"C":{"ewasm":{"wast":"(module
    (import \"ethereum\" \"revert\" (func $eth.revert (param i32 i32)))
    (memory $memory (export \"memory\") 1)
    (export \"main\" (func $main))

(func $main
    (local $_1 i64)
    (local $_2 i64)
    (local $_3 i64)
    (local $hi i64)
    (local $y i64)
    (local $hi_1 i64)
    (local.set $_1 (i64.const 0))
    (local.set $_2 (i64.add (call $u256_to_i32 (local.get $_1) (local.get $_1) (local.get $_1) (i64.const 64)) (i64.const 64)))
    (local.set $_3 (i64.const 65280))
    (local.set $hi (i64.shl (i64.or (i64.shl (i64.or (i64.and (i64.shl (local.get $_1) (i64.const 8)) (local.get $_3)) (i64.and (i64.shr_u (local.get $_1) (i64.const 8)) (i64.const 255))) (i64.const 16)) (call $endian_swap_16 (i64.shr_u (local.get $_1) (i64.const 16)))) (i64.const 32)))
    (local.set $y (i64.or (local.get $hi) (call $endian_swap_32 (i64.shr_u (local.get $_1) (i64.const 32)))))
    (i64.store (local.get $_2) (local.get $y))
    (i64.store (i64.add (local.get $_2) (i64.const 8)) (local.get $y))
    (i64.store (i64.add (local.get $_2) (i64.const 16)) (local.get $y))
    (local.set $hi_1 (i64.shl (i64.or (i64.shl (i64.or (i64.and (i64.shl (i64.const 128) (i64.const 8)) (local.get $_3)) (i64.and (i64.shr_u (i64.const 128) (i64.const 8)) (i64.const 255))) (i64.const 16)) (call $endian_swap_16 (i64.shr_u (i64.const 128) (i64.const 16)))) (i64.const 32)))
    (i64.store (i64.add (local.get $_2) (i64.const 24)) (i64.or (local.get $hi_1) (call $endian_swap_32 (i64.shr_u (i64.const 128) (i64.const 32)))))
    (call $eth.revert (i64.add (call $u256_to_i32 (local.get $_1) (local.get $_1) (local.get $_1) (local.get $_1)) (i64.const 64)) (call $u256_to_i32 (local.get $_1) (local.get $_1) (local.get $_1) (local.get $_1)))
)

(func $u256_to_i32
    (param $x1 i64)
    (param $x2 i64)
    (param $x3 i64)
    (param $x4 i64)
    (result i64)
    (local $v i64)
    (if (i64.ne (local.get $v) (i64.or (i64.or (local.get $x1) (local.get $x2)) (local.get $x3))) (then
        (unreachable)))
    (if (i64.ne (local.get $v) (i64.shr_u (local.get $x4) (i64.const 32))) (then
        (unreachable)))
    (local.set $v (local.get $x4))
    (local.get $v)
)

(func $endian_swap_16
    (param $x i64)
    (result i64)
    (local $y i64)
    (local.set $y (i64.or (i64.and (i64.shl (local.get $x) (i64.const 8)) (i64.const 65280)) (i64.and (i64.shr_u (local.get $x) (i64.const 8)) (i64.const 255))))
    (local.get $y)
)

(func $endian_swap_32
    (param $x i64)
    (result i64)
    (local $y i64)
    (local $hi i64)
    (local.set $hi (i64.shl (call $endian_swap_16 (local.get $x)) (i64.const 16)))
    (local.set $y (i64.or (local.get $hi) (call $endian_swap_16 (i64.shr_u (local.get $x) (i64.const 16)))))
    (local.get $y)
)

)
(module
    (import \"ethereum\" \"codeCopy\" (func $eth.codeCopy (param i32 i32 i32)))
    (import \"ethereum\" \"finish\" (func $eth.finish (param i32 i32)))
    (memory $memory (export \"memory\") 1)
    (export \"main\" (func $main))
    (global $global_ (mut i64) (i64.const 0))
    (global $global__1 (mut i64) (i64.const 0))
    (global $global__2 (mut i64) (i64.const 0))

(func $main
    (local $_1 i64)
    (local $_2 i64)
    (local $hi i64)
    (local $y i64)
    (local $hi_1 i64)
    (local $_3 i64)
    (local $_4 i64)
    (local $_5 i64)
    (local $_6 i64)
    (local $_7 i64)
    (local $_8 i64)
    (local $_9 i64)
    (local $_10 i64)
    (local.set $_1 (i64.const 0))
    (local.set $_2 (i64.add (call $u256_to_i32 (local.get $_1) (local.get $_1) (local.get $_1) (i64.const 64)) (i64.const 64)))
    (local.set $hi (i64.shl (i64.or (i64.shl (i64.or (i64.and (i64.shl (local.get $_1) (i64.const 8)) (i64.const 65280)) (i64.and (i64.shr_u (local.get $_1) (i64.const 8)) (i64.const 255))) (i64.const 16)) (call $endian_swap_16 (i64.shr_u (local.get $_1) (i64.const 16)))) (i64.const 32)))
    (local.set $y (i64.or (local.get $hi) (call $endian_swap_32 (i64.shr_u (local.get $_1) (i64.const 32)))))
    (i64.store (local.get $_2) (local.get $y))
    (i64.store (i64.add (local.get $_2) (i64.const 8)) (local.get $y))
    (i64.store (i64.add (local.get $_2) (i64.const 16)) (local.get $y))
    (local.set $hi_1 (i64.shl (call $endian_swap_32 (i64.const 128)) (i64.const 32)))
    (i64.store (i64.add (local.get $_2) (i64.const 24)) (i64.or (local.get $hi_1) (call $endian_swap_32 (i64.shr_u (i64.const 128) (i64.const 32)))))
    (block
        (local.set $_3 (datasize \"C_2_deployed\"))
        (local.set $_4 (global.get $global_))
        (local.set $_5 (global.get $global__1))
        (local.set $_6 (global.get $global__2))

    )
    (block
        (local.set $_7 (dataoffset \"C_2_deployed\"))
        (local.set $_8 (global.get $global_))
        (local.set $_9 (global.get $global__1))
        (local.set $_10 (global.get $global__2))

    )
    (call $eth.codeCopy (i64.add (call $u256_to_i32 (local.get $_1) (local.get $_1) (local.get $_1) (local.get $_1)) (i64.const 64)) (call $u256_to_i32 (local.get $_7) (local.get $_8) (local.get $_9) (local.get $_10)) (call $u256_to_i32 (local.get $_3) (local.get $_4) (local.get $_5) (local.get $_6)))
    (call $eth.finish (i64.add (call $u256_to_i32 (local.get $_1) (local.get $_1) (local.get $_1) (local.get $_1)) (i64.const 64)) (call $u256_to_i32 (local.get $_3) (local.get $_4) (local.get $_5) (local.get $_6)))
)

(func $u256_to_i32
    (param $x1 i64)
    (param $x2 i64)
    (param $x3 i64)
    (param $x4 i64)
    (result i64)
    (local $v i64)
    (if (i64.ne (local.get $v) (i64.or (i64.or (local.get $x1) (local.get $x2)) (local.get $x3))) (then
        (unreachable)))
    (if (i64.ne (local.get $v) (i64.shr_u (local.get $x4) (i64.const 32))) (then
        (unreachable)))
    (local.set $v (local.get $x4))
    (local.get $v)
)

(func $endian_swap_16
    (param $x i64)
    (result i64)
    (local $y i64)
    (local.set $y (i64.or (i64.and (i64.shl (local.get $x) (i64.const 8)) (i64.const 65280)) (i64.and (i64.shr_u (local.get $x) (i64.const 8)) (i64.const 255))))
    (local.get $y)
)

(func $endian_swap_32
    (param $x i64)
    (result i64)
    (local $y i64)
    (local $hi i64)
    (local.set $hi (i64.shl (call $endian_swap_16 (local.get $x)) (i64.const 16)))
    (local.set $y (i64.or (local.get $hi) (call $endian_swap_16 (i64.shr_u (local.get $x) (i64.const 16)))))
    (local.get $y)
)

)
"}}}},"errors":[{"component":"general","formattedMessage":"Warning: The Yul optimiser is still experimental. Do not use it in production unless correctness of generated code is verified with extensive tests.
","message":"The Yul optimiser is still experimental. Do not use it in production unless correctness of generated code is verified with extensive tests.","severity":"warning","type":"Warning"}],"sources":{"A":{"id":0}}}
